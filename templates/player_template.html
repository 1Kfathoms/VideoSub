<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Language Player</title>
    <style>
        :root {
            --base-font-size: 16px;
            --bg-color: #1e1e1e;
            --text-color: #fff;
            --highlight-color: #00FFFF;
            --search-highlight: #FFB90C;
            --panel-bg: #222;
            --border-color: #444;
            --btn-hover-bg: #444;
        }
        body { margin: 0; display: flex; height: 100vh; font-family: 'Segoe UI', sans-serif; background: var(--bg-color); color: var(--text-color); overflow: hidden; }
        
        /* Flex Layout Logic */
        #main-wrapper { display: flex; width: 100%; height: 100%; flex-direction: row; }
        
        /* Video Section */
        #video-container { flex: 0 0 70%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #000; position: relative; min-width: 200px; min-height: 200px; }
        video { max-width: 100%; max-height: 100%; }
        
        /* Resizer */
        #resizer { background: #333; z-index: 10; transition: background 0.2s; flex: 0 0 8px; position: relative; }
        #resizer:hover, #resizer.active { background: var(--highlight-color); }
        #resizer.horizontal { cursor: row-resize; height: 8px; width: 100%; flex: 0 0 8px; }
        #resizer.vertical { cursor: col-resize; width: 8px; height: 100%; flex: 0 0 8px; }

        /* Transcript Section */
        #transcript-container { flex: 1; display: flex; flex-direction: column; min-width: 200px; min-height: 200px; background: var(--bg-color); font-size: var(--base-font-size); position: relative; }
        
        /* Header Bar */
        #controls-header { 
            display: flex; align-items: center; padding: 8px; background: var(--panel-bg); 
            border-bottom: 1px solid var(--border-color); gap: 8px; flex-wrap: nowrap; overflow-x: hidden;
        }
        
        /* Search Box */
        .search-group { 
            display: flex; align-items: center; background: #333; border: 1px solid var(--border-color); 
            border-radius: 4px; padding: 2px 5px; flex: 1 1 auto; min-width: 160px; max-width: 400px;
        }
        #search-box { 
            background: transparent; border: none; color: #fff; padding: 4px; font-size: 0.9em; 
            flex: 1; width: 50px; outline: none; min-width: 30px; 
        }
        #search-count { font-size: 0.8em; color: #aaa; margin: 0 8px; white-space: nowrap; user-select: none; }
        .search-btn { background: none; border: none; color: #aaa; cursor: pointer; padding: 2px 6px; font-size: 1em; border-left: 1px solid #444; flex-shrink: 0; }
        .search-btn:hover { color: #fff; background: #444; }

        /* General Buttons */
        .icon-btn { 
            background: #333; border: 1px solid var(--border-color); color: #fff; padding: 5px 10px; 
            border-radius: 4px; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; 
            justify-content: center; user-select: none; flex-shrink: 0; white-space: nowrap;
        }
        .icon-btn:hover { background: #444; }
        
        /* Settings Panel */
        #settings-panel { display: none; position: absolute; top: 45px; right: 10px; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px; z-index: 1001; box-shadow: 0 4px 12px rgba(0,0,0,0.5); min-width: 150px; }
        .setting-item { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: 0.9em; }
        .font-ctrl-group { display: flex; gap: 5px; }
        
        /* Transcript Content & Segments */
        #content { flex: 1; overflow-y: auto; padding: 10px; }
        
        /* Segment Layout (Flex for side buttons) */
        .segment { 
            display: flex; 
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 0.5em; 
            padding: 0.25em; 
            border-radius: 4px; 
            transition: background 0.2s; 
        }
        .segment:hover { background: #2a2a2a; }

        .segment-text-area { flex: 1; } /* Holds words and translation */
        
        .segment-actions {
            display: flex;
            flex-direction: column;
            gap: 4px;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.2s;
            padding-top: 2px;
        }
        /* Show actions on hover (Desktop) or if active logic needed */
        .segment:hover .segment-actions { opacity: 1; }

        .action-btn {
            background: transparent;
            border: 1px solid #444;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75em;
            padding: 2px 6px;
            text-align: center;
            min-width: 24px;
        }
        .action-btn:hover { background: var(--highlight-color); color: #000; border-color: var(--highlight-color); }

        .word { cursor: pointer; padding: 0 2px; border-radius: 4px; transition: all 0.1s; display: inline-block; line-height: 1.2; }
        .word:hover { background: #444; }
        .word.active { background: var(--highlight-color); color: #000; }
        .word.search-highlight { background: var(--search-highlight); color: #000; }
        .word.search-focus { outline: 2px solid #fff; box-shadow: 0 0 5px var(--search-highlight); }
        .translation { display: block; margin-top: 0.2em; color: #aaa; font-size: 0.85em; border-left: 2px solid #555; padding-left: 6px; }

        /* Dict Tooltip */
        .dict-tooltip { position: fixed; max-width: 320px; background: #111; color: #fff; border: 1px solid #444; border-radius: 6px; padding: 12px; box-shadow: 0 4px 14px rgba(0,0,0,0.5); font-size: 0.9rem; z-index: 2000; max-height: 60vh; overflow-y: auto; display: none; pointer-events: auto; }
        .dict-header { display: flex; align-items: center; gap: 8px; border-bottom: 1px solid #333; padding-bottom: 6px; margin-bottom: 6px; }
        .dict-word { font-weight: bold; font-size: 1.1em; }
        .dict-pos { background: #333; color: var(--highlight-color); padding: 1px 4px; border-radius: 3px; font-size: 0.75em; margin-right: 6px; border: 1px solid #444; }
        
        /* Tooltip buttons */
        .tooltip-btn { background: none; border: none; cursor: pointer; color: #aaa; font-size: 1.1em; padding: 0 4px; margin-left: 4px; transition: color 0.2s; }
        .tooltip-btn:hover { color: #fff; }
        .tooltip-btn.copy-time { font-size: 0.9em; border: 1px solid #444; border-radius: 3px; padding: 1px 4px; margin-left: auto;}
        .tooltip-btn.copy-time:hover { background: #333; color: var(--highlight-color); }

        /* Error Message */
        #error-message { display: none; color: #ff5555; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; pointer-events: none; }

        @media (max-width: 768px) {
            #main-wrapper { flex-direction: column; }
            #video-container { flex: 0 0 40%; width: 100%; border-bottom: none; }
            #resizer.vertical { display: none; }
            .segment-actions { opacity: 1; /* Always show buttons on mobile */ flex-direction: row; } 
        }
    </style>
</head>
<body>

    <div id="main-wrapper">
        <div id="video-container">
            <div id="error-message"></div>
            <video id="player" controls playsinline webkit-playsinline preload="auto"></video>
        </div>

        <div id="resizer" class="vertical"></div>

        <div id="transcript-container">
            <div id="controls-header">
                <button id="pip-btn" class="icon-btn" onclick="togglePiP()" title="Picture in Picture">‚ßâ PiP</button>
                
                <div class="search-group">
                    <input type="text" id="search-box" placeholder="Ê§úÁ¥¢...">
                    <span id="search-count">0/0</span>
                    <button class="search-btn" id="search-prev" onclick="navSearch(-1)">‚ñ≤</button>
                    <button class="search-btn" id="search-next" onclick="navSearch(1)">‚ñº</button>
                </div>

                <button id="settings-btn" class="icon-btn" onclick="toggleSettings(event)" title="Ë®≠ÂÆö">‚öôÔ∏è</button>
            </div>

            <div id="settings-panel">
                <div class="setting-item">
                    <span class="setting-label">ÊñáÂ≠ó„Çµ„Ç§„Ç∫</span>
                    <div class="font-ctrl-group">
                        <button class="icon-btn" onclick="changeFontSize(-1)">A-</button>
                        <button class="icon-btn" onclick="changeFontSize(1)">A+</button>
                    </div>
                </div>
            </div>

            <div id="content"></div>
        </div>
    </div>

    <div id="dict-tooltip" class="dict-tooltip"></div>
    
    <script src="data.js"></script>
    <script>
        // --- State Variables ---
        const player = document.getElementById('player');
        const contentDiv = document.getElementById('content');
        const dictTooltip = document.getElementById('dict-tooltip');
        const mainWrapper = document.getElementById('main-wrapper');
        const resizer = document.getElementById('resizer');
        const videoContainer = document.getElementById('video-container');
        const settingsPanel = document.getElementById('settings-panel');
        
        let pipWindowRef = null;

        // Search State
        let allWords = [];
        let searchMatches = [];
        let currentMatchIndex = -1;

        // Tooltip State
        let hoverActiveCount = 0;
        let resumeAfterHover = false;
        let hoverDebounceTimer = null;
        let tooltipHideTimer = null;
        let dictCache = new Map();
        let currentHoverWordStart = 0; // Stores start time for tooltip button

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof MEDIA_DATA === 'undefined') {
                showError('data.js „ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ');
                return;
            }
            player.src = MEDIA_DATA.videoFile;
            
            renderSegments();
            
            allWords = Array.from(document.querySelectorAll('.word')).map(el => ({
                el: el, 
                start: parseFloat(el.dataset.start), 
                end: parseFloat(el.dataset.end)
            }));

            checkLayout();
            window.addEventListener('resize', checkLayout);
            attemptAutoplay();
            requestAnimationFrame(updateHighlight);
            
            // Global Shortcuts
            document.addEventListener('keydown', handleGlobalKeydown);
        });

        function renderSegments() {
            MEDIA_DATA.segments.forEach((segment) => {
                // Main Container
                const segDiv = document.createElement('div');
                segDiv.className = 'segment';
                segDiv.dataset.start = segment.start;
                
                // Left: Text Content
                const contentArea = document.createElement('div');
                contentArea.className = 'segment-text-area';

                let segmentText = ""; // Accumulate text for copy

                segment.words.forEach((w, index) => {
                    const span = document.createElement('span');
                    span.className = 'word';
                    span.innerText = w.word;
                    span.dataset.start = w.start;
                    span.dataset.end = w.end;
                    
                    // Add space before word (except for first word)
                    if (index > 0) {
                        segmentText += " ";
                    }
                    segmentText += w.word;

                    span.onclick = (e) => {
                        e.stopPropagation();
                        safeSeek(w.start);
                    };

                    setupHoverEvents(span, w.word, w.start);
                    contentArea.appendChild(span);
                });
                
                const trans = document.createElement('span');
                trans.className = 'translation';
                trans.innerText = segment.translation;
                contentArea.appendChild(trans);
                
                // Right: Actions (Buttons)
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'segment-actions';
                
                // Copy Text Button
                const btnCopyText = document.createElement('button');
                btnCopyText.className = 'action-btn';
                btnCopyText.innerText = 'üìã';
                btnCopyText.title = 'Ëã±Êñá„Çí„Ç≥„Éî„Éº';
                btnCopyText.onclick = (e) => {
                    e.stopPropagation();
                    copyToClipboard(segmentText);
                };

                // Copy Time Button
                const btnCopyTime = document.createElement('button');
                btnCopyTime.className = 'action-btn';
                btnCopyTime.innerText = '‚è±Ô∏è';
                btnCopyTime.title = 'ÈñãÂßãÊôÇÈñì„Çí„Ç≥„Éî„Éº (Áßí)';
                btnCopyTime.onclick = (e) => {
                    e.stopPropagation();
                    copyToClipboard(Math.floor(segment.start).toString());
                };

                actionsDiv.appendChild(btnCopyText);
                actionsDiv.appendChild(btnCopyTime);

                // Combine
                segDiv.appendChild(contentArea);
                segDiv.appendChild(actionsDiv);
                contentDiv.appendChild(segDiv);
            });
        }

        // --- Utils ---
        async function copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
                // Simple visual feedback (optional)
                console.log('Copied:', text);
            } catch (err) {
                console.error('Copy failed', err);
                alert('„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü (HTTPS„Åæ„Åü„ÅØlocalhost„ÅåÂøÖË¶Å„Åß„Åô)');
            }
        }

        // --- Tooltip & Hover Logic ---
        function setupHoverEvents(element, wordText, startTime) {
            element.addEventListener('mouseenter', (ev) => {
                if (tooltipHideTimer) clearTimeout(tooltipHideTimer);
                
                // Store time for tooltip button
                currentHoverWordStart = startTime;

                if (hoverActiveCount === 0) resumeAfterHover = !player.paused && !player.ended;
                hoverActiveCount++;
                if (!player.paused) player.pause();

                dictTooltip.style.display = 'block';
                // Show temporary loader with Time Copy button immediately available
                dictTooltip.innerHTML = generateTooltipHeader('Loading...', false); 
                positionTooltip(ev);

                if (hoverDebounceTimer) clearTimeout(hoverDebounceTimer);
                hoverDebounceTimer = setTimeout(async () => {
                    const html = await fetchDefinition(wordText);
                    if(dictTooltip.style.display !== 'none') {
                        dictTooltip.innerHTML = html;
                        positionTooltip(ev);
                    }
                }, 150);
            });

            element.addEventListener('mouseleave', () => {
                if (hoverDebounceTimer) clearTimeout(hoverDebounceTimer);
                handleMouseLeave();
            });
        }

        dictTooltip.addEventListener('mouseenter', () => {
            if (tooltipHideTimer) clearTimeout(tooltipHideTimer);
            if (hoverActiveCount === 0) resumeAfterHover = !player.paused && !player.ended;
            hoverActiveCount++;
            if (!player.paused && !player.ended) player.pause();
        });

        dictTooltip.addEventListener('mouseleave', () => {
            handleMouseLeave();
        });

        function handleMouseLeave() {
            hoverActiveCount = Math.max(0, hoverActiveCount - 1);
            if (hoverActiveCount === 0) {
                if (resumeAfterHover) player.play().catch(()=>{});
                resumeAfterHover = false;
                tooltipHideTimer = setTimeout(() => dictTooltip.style.display = 'none', 300);
            }
        }

        // --- Audio & Dict ---
        function speakWord(text) {
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                window.speechSynthesis.speak(utterance);
            }
        }

        // Helper to generate consistent header with Time Copy Button
        function generateTooltipHeader(word, showSpeaker = true) {
            const timeInt = Math.floor(currentHoverWordStart);
            let html = `<div class="dict-header">`;
            html += `<span class="dict-word">${word}</span>`;
            
            // Time Copy Button (Always right aligned)
            html += `<button class="tooltip-btn copy-time" onclick="copyToClipboard('${timeInt}')" title="ÊôÇÈñì„Çí„Ç≥„Éî„Éº: ${timeInt}">‚è±Ô∏è ${timeInt}s</button>`;
            
            // Speaker Button (Optional)
            if (showSpeaker) {
                html += `<button class="tooltip-btn" onclick="speakWord('${word.replace(/'/g, "\\'")}')" title="Áô∫Èü≥">üîä</button>`;
            }
            
            html += `</div>`;
            return html;
        }

        async function fetchDefinition(word) {
            const query = word.replace(/[^a-zA-Z]/g, '');
            if (!query) return generateTooltipHeader(word, false) + 'No definition';
            
            if (dictCache.has(query)) return dictCache.get(query);
            
            try {
                const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${query}`);
                if (!res.ok) throw new Error();
                const data = await res.json();
                
                const entry = data[0];
                let html = generateTooltipHeader(entry.word, true);
                
                if(entry.phonetic) html += `<div style="color:#888; margin-bottom:4px; font-size:0.9em;">${entry.phonetic}</div>`;
                
                entry.meanings.slice(0,2).forEach(m => {
                    const def = m.definitions[0]?.definition;
                    if(def) html += `<div style="margin-bottom:6px;"><span class="dict-pos">${m.partOfSpeech}</span>${def}</div>`;
                });
                
                dictCache.set(query, html);
                return html;
            } catch(e) {
                const err = generateTooltipHeader(query, false) + `<div style="color:#888; margin-top:5px;">ËæûÊõ∏„Éá„Éº„Çø„Å™„Åó</div>`;
                dictCache.set(query, err);
                return err;
            }
        }

        // --- Layout & Resizing ---
        let isResizing = false;

        function checkLayout() {
            const isColumn = window.innerWidth <= 768 || mainWrapper.style.flexDirection === 'column';
            if (isColumn) {
                mainWrapper.style.flexDirection = 'column';
                resizer.className = 'horizontal';
            } else {
                mainWrapper.style.flexDirection = 'row';
                resizer.className = 'vertical';
            }
        }

        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isResizing = true;
            resizer.classList.add('active');
            
            const isColumnMode = mainWrapper.style.flexDirection === 'column' || window.innerWidth <= 768;
            const isVerticalMode = !isColumnMode; 

            document.body.style.userSelect = 'none';
            document.body.style.cursor = isVerticalMode ? 'col-resize' : 'row-resize';
            
            videoContainer.style.pointerEvents = 'none';

            const doDrag = (ev) => {
                if (!isResizing) return;
                
                if (isVerticalMode) {
                    const newWidth = ev.clientX;
                    videoContainer.style.flex = `0 0 ${newWidth}px`;
                    videoContainer.style.width = `${newWidth}px`;
                    videoContainer.style.height = 'auto';
                } else {
                    const newHeight = ev.clientY;
                    videoContainer.style.flex = `0 0 ${newHeight}px`;
                    videoContainer.style.height = `${newHeight}px`;
                    videoContainer.style.width = '100%';
                }
            };

            const stopDrag = () => {
                isResizing = false;
                resizer.classList.remove('active');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                videoContainer.style.pointerEvents = '';
                
                window.removeEventListener('mousemove', doDrag);
                window.removeEventListener('mouseup', stopDrag);
            };

            window.addEventListener('mousemove', doDrag);
            window.addEventListener('mouseup', stopDrag);
        });

        // --- Search Functionality ---
        const searchBox = document.getElementById('search-box');
        const searchCount = document.getElementById('search-count');

        searchBox.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            allWords.forEach(w => w.el.classList.remove('search-highlight', 'search-focus'));
            searchMatches = [];
            currentMatchIndex = -1;

            if (!query) {
                searchCount.innerText = "0/0";
                return;
            }

            allWords.forEach(w => {
                if (w.el.innerText.toLowerCase().includes(query)) {
                    w.el.classList.add('search-highlight');
                    searchMatches.push(w);
                }
            });

            if (searchMatches.length > 0) {
                currentMatchIndex = 0;
                highlightMatch(0);
            }
            updateSearchUI();
        });

        function navSearch(direction) {
            if (searchMatches.length === 0) return;
            currentMatchIndex += direction;
            if (currentMatchIndex >= searchMatches.length) currentMatchIndex = 0;
            if (currentMatchIndex < 0) currentMatchIndex = searchMatches.length - 1;
            highlightMatch(currentMatchIndex);
            updateSearchUI();
        }

        function highlightMatch(index) {
            searchMatches.forEach(w => w.el.classList.remove('search-focus'));
            const target = searchMatches[index];
            target.el.classList.add('search-focus');
            target.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function updateSearchUI() {
            if (searchMatches.length === 0) {
                searchCount.innerText = "0/0";
            } else {
                searchCount.innerText = `${currentMatchIndex + 1}/${searchMatches.length}`;
            }
        }
        
        searchBox.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') navSearch(1);
        });

        // --- Settings & Font Size ---
        let currentFontSize = 16;
        
        function toggleSettings(ev) {
            if(ev) ev.stopPropagation();
            const display = settingsPanel.style.display;
            settingsPanel.style.display = display === 'block' ? 'none' : 'block';
        }

        function changeFontSize(delta) {
            currentFontSize += delta;
            if (currentFontSize < 10) currentFontSize = 10;
            if (currentFontSize > 32) currentFontSize = 32;
            const sizeStr = `${currentFontSize}px`;
            
            document.documentElement.style.setProperty('--base-font-size', sizeStr);
            if (pipWindowRef) {
                pipWindowRef.document.documentElement.style.setProperty('--base-font-size', sizeStr);
            }
        }
        
        document.addEventListener('click', (e) => {
            if (!settingsPanel.contains(e.target)) {
                settingsPanel.style.display = 'none';
            }
        });

        // --- Shortcuts (Global Handler) ---
        function handleGlobalKeydown(e) {
            // Ignore if typing in search box
            // Note: In PiP, the search box is in a different document, so check activeElement carefully if searching there.
            // Simplified check:
            const activeTag = (e.target.tagName || "").toLowerCase();
            if (activeTag === 'input' || activeTag === 'textarea') return;

            const t = player.currentTime;
            switch(e.key.toLowerCase()) {
                case 'arrowleft': safeSeek(t - 5); break;
                case 'arrowright': safeSeek(t + 5); break;
                case 's': jumpToSegment('current'); break;
                case 'a': jumpToSegment('prev'); break;
                case 'd': jumpToSegment('next'); break;
            }
        }

        function jumpToSegment(mode) {
            const t = player.currentTime;
            let idx = MEDIA_DATA.segments.findIndex(s => t >= s.start && t < s.end);
            
            if (idx === -1) {
                idx = MEDIA_DATA.segments.findIndex(s => s.start > t);
                if (idx === -1) idx = MEDIA_DATA.segments.length - 1; 
                else if (mode === 'current' || mode === 'prev') idx = Math.max(0, idx - 1);
            }

            let targetIdx = idx;
            if (mode === 'prev') targetIdx = Math.max(0, idx - 1);
            if (mode === 'next') targetIdx = Math.min(MEDIA_DATA.segments.length - 1, idx + 1);

            if (MEDIA_DATA.segments[targetIdx]) {
                safeSeek(MEDIA_DATA.segments[targetIdx].start);
            }
        }

        function safeSeek(time) {
            if (!Number.isFinite(time)) return;
            time = Math.max(0, Math.min(time, player.duration || 99999));
            if (player.fastSeek) player.fastSeek(time);
            else player.currentTime = time;
        }

        function updateHighlight() {
            if (!player.paused) {
                const t = player.currentTime;
                for (const w of allWords) {
                    if (t >= w.start && t < w.end) {
                        if (!w.el.classList.contains('active')) {
                            w.el.classList.add('active');
                            if (!isResizing && dictTooltip.style.display !== 'block') {
                                w.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }
                    } else {
                        w.el.classList.remove('active');
                    }
                }
            }
            requestAnimationFrame(updateHighlight);
        }

        function attemptAutoplay() {
            player.play().catch(() => {
                player.muted = true;
                player.play().catch(()=>{});
            });
        }
        
        function showError(msg) {
            const e = document.getElementById('error-message');
            e.innerText = msg;
            e.style.display = 'block';
        }

        // --- PiP (Doc PiP) ---
        async function togglePiP() {
            if (!window.documentPictureInPicture) {
                alert("„Åì„ÅÆÊ©üËÉΩ„ÅØDocument PiP API„Å´ÂØæÂøú„Åó„Åü„Éñ„É©„Ç¶„Ç∂„ÅÆ„ÅøÂà©Áî®ÂèØËÉΩ„Åß„Åô„ÄÇ");
                return;
            }
            if (window.documentPictureInPicture.window) {
                window.documentPictureInPicture.window.close();
                return;
            }

            try {
                const pipWin = await window.documentPictureInPicture.requestWindow({
                    width: 400, height: 600
                });
                
                pipWindowRef = pipWin; 

                // Attach shortcuts to PiP window
                pipWin.document.addEventListener('keydown', handleGlobalKeydown);
                pipWin.speakWord = speakWord;
                // Expose copy helper to PiP scope if needed, or function scoping handles it.
                // Note: navigator.clipboard might require the user gesture to be on the pip window directly.
                // Clicking the button inside PiP IS a gesture on PiP, so it should work.

                [...document.styleSheets].forEach(sheet => {
                    try {
                        const style = document.createElement('style');
                        style.textContent = [...sheet.cssRules].map(r => r.cssText).join('');
                        pipWin.document.head.appendChild(style);
                    } catch(e) {}
                });

                pipWin.document.documentElement.style.setProperty('--base-font-size', `${currentFontSize}px`);

                pipWin.document.body.appendChild(mainWrapper);
                
                mainWrapper.style.flexDirection = 'column';
                resizer.className = 'horizontal';
                videoContainer.style.flex = '0 0 50%';
                videoContainer.style.width = '100%';
                
                // Patch Resizer for PiP
                const pipResizer = mainWrapper.querySelector('#resizer');
                pipResizer.onmousedown = (e) => {
                    e.preventDefault();
                    isResizing = true;
                    pipResizer.classList.add('active');
                    videoContainer.style.pointerEvents = 'none';
                    
                    const doDrag = (ev) => {
                        const h = ev.clientY;
                        videoContainer.style.flex = `0 0 ${h}px`;
                        videoContainer.style.height = `${h}px`;
                    };
                    const stopDrag = () => {
                        isResizing = false;
                        pipResizer.classList.remove('active');
                        videoContainer.style.pointerEvents = '';
                        pipWin.document.removeEventListener('mousemove', doDrag);
                        pipWin.document.removeEventListener('mouseup', stopDrag);
                    };
                    pipWin.document.addEventListener('mousemove', doDrag);
                    pipWin.document.addEventListener('mouseup', stopDrag);
                };
                
                pipWin.document.body.appendChild(dictTooltip);

                pipWin.addEventListener('pagehide', () => {
                    pipWindowRef = null;
                    document.body.appendChild(mainWrapper);
                    document.body.appendChild(dictTooltip);
                    mainWrapper.style.flexDirection = ''; 
                    checkLayout(); 
                });

            } catch(e) {
                console.error(e);
            }
        }
        
        function positionTooltip(ev) {
            const targetDoc = ev.target.ownerDocument;
            const win = targetDoc.defaultView;
            
            const margin = 10;
            let x = ev.clientX + margin;
            let y = ev.clientY + margin;
            
            dictTooltip.style.display = 'block';
            const rect = dictTooltip.getBoundingClientRect();
            
            if (x + rect.width > win.innerWidth) x = ev.clientX - rect.width - margin;
            if (y + rect.height > win.innerHeight) y = ev.clientY - rect.height - margin;
            
            dictTooltip.style.left = x + 'px';
            dictTooltip.style.top = y + 'px';
        }
    </script>
</body>
</html>